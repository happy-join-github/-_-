算法复杂度介绍

> 算法复杂度:在问题的输入规模为N的条件下，程序的时间使用情况和空间使用情况。

「算法分析」的目的在于改进算法。正如前辈所说的那样：算法所追求的就是**所需运行时间更少(时间复杂度)，占用内存空间更少(空间复杂度)**

比较两个算法的优劣通常有两种方法：

- 事后统计：将两个算法编写为可执行程序，交给计算机执行，记录各自运行的时间和内存占用情况，从中挑选最好的算法
- 预算估计：在算法设计出来后，根据算法中包含的步骤，估量出算法的运行时间和占用空间。比较两个算法的估算值，从中挑选最好的算法。

大多数情况下我们会选择第二种方法，因为第一种办法的可行性太低，而且影响因素太多。所以我们一般采用预先估算的方法衡量算法的优劣度。



采用预先估算的方式下，编译语言、计算机运行速度都不是我们所考虑的对象。我们只关心随着问题规模 N扩大时，时间开销、空间开销的增长趋势。

这里的 **「问题规模 N」** 指的是：算法问题输入的数据量大小。对于不同的算法，定义也不相同。

- 排序算法中：$n$ 表示需要排序的元素数量。
- 查找算法中：$n$ 表示查找范围内的元素总数：比如数组大小、二维矩阵大小、字符串长度、二叉树节点数、图的节点数、图的边界点等。
- 二进制计算相关算法中：$n$ 表示二进制的展开宽度。

一般来说，问题的输入规模越接近，相应的计算成本也越接近。而随着问题输入规模的扩大，计算成本也呈上升趋势。



## 时间复杂度

> **时间复杂度（Time Complexity）**：在问题的输入规模为 N 的条件下，算法运行所需要花费的时间，可以记作为 T(N)。

我们将 **基本操作次数** 作为时间复杂度的度量标准。换句话说，时间复杂度跟算法中基本操作次数的数量正相关。

- **基本操作** ：算法执行中的每一条语句。每一次基本操作都可在常数时间内完成。

基本操作是一个运行时间不依赖于操作数的操作。

比如两个整数相加的操作，如果两个数的规模不大，运行时间不依赖于整数的位数，则相加操作就可以看做是基本操作。

反之，如果两个数的规模很大，相加操作依赖于两个数的位数，则两个数的相加操作不是一个基本操作，而每一位数的相加操作才是一个基本操作。

下面通过一个具体例子来说明一下如何计算时间复杂度。

```python
def algorithm(n):
    fact = 1
    for i in range(1, n + 1):
        fact *= i
    return fact
```

把上述算法中所有语句的执行次数加起来 1 + n + n + 1 = 2n + 2 ，可以用一个函数 $f(n)$ 来表达语句的执行次数：f(n) = 2n + 2。

则时间复杂度的函数可以表示为：T(n) = O(f(n))。它表示的是随着问题规模 n 的增大，算法执行时间的增长趋势跟 f(n) 相同。O 是一种渐进符号，T(n) 称作算法的 **渐进时间复杂度（Asymptotic Time Complexity）**，简称为 **时间复杂度**。

所谓「**算法执行时间的增长趋势**」是一个模糊的概念，通常我们要借助像上边公式中 O 这样的「渐进符号」来表示时间复杂度。

## 时间复杂度计算

求解时间复杂度一般分为以下几个步骤：

- **找出算法中的基本操作（基本语句）**：算法中执行次数最多的语句就是基本语句，通常是最内层循环的循环体部分。
- **计算基本语句执行次数的数量级**：只需要计算基本语句执行次数的数量级，即保证函数中的最高次幂正确即可。像最高次幂的系数和低次幂可以忽略。
- **用大 O 表示法表示时间复杂度**：将上一步中计算的数量级放入 O 渐进上界符号中。

同时，在求解时间复杂度还要注意一些原则：

- **加法原则**：总的时间复杂度等于量级最大的基本语句的时间复杂度。
- **乘法原则**：循环嵌套代码的复杂度等于嵌套内外基本语句的时间复杂度乘积。

常见的时间复杂度(从小到大顺序)

```python
#O(1)
#一般不包含循环语句、递归语句其时间复杂度都为O(1)
def add(a,b):
    d=2
    e=4
    return a+b+d+e
#上面的时间复杂度不是O(2)而是O(1)的原因是我们只关心输入规模与算法运行时间的增长趋势。而不是具体的值。
```

```python
#O(logN)
#常见的算法二分查找、分治算法
#二分查找算法
def binarySearch(arr:list,target:int)->int:
    #假设数组为[1,2,3,4,5,6],在这个数组中查找元素4
    i,j=0,len(arr)-1
    while i<=j:
        middle=(i+j)//2
        if arr[middle]>target:
            j=middle-1
        elif arr[middle]<target:
            i=middle+1
        else:
            return i
    return -1
```

```python
#O(N)
#一般含有非嵌套循环，且循环的次数为N的算法
def add(n):
    sum_num=0
    for i in range(n):
        sum_num+=i
    return sum
```

```python
#O(nlogN)
#常见的算法快速排序、归并排序、堆排序
def algorithm(n):
    cnt=1
    res=0
    while cnt<n:
        cnt *=2
        for i in range(n):
            res+=1
    return res
#内层循环O(N)外层循环O(logN)
```

```python
#O(n**2)
def algorithm(n):
    res=0
    for i in range(n):
        for j in range(n,-1,-1):
            res+=i+j
```

```python
#O(N!)这种时间复杂度的算法根本没见过，也不要写这种算法。数据规模非常大的时候，程序有尔铿直接崩了。
#全排列
def permute(nums):
    result = [[]]
    for i in range(len(nums)):
        for p in result:
            NewP = p.copy()
            NewP.append(nums[i])
            result.append(NewP)
    return result
```

我们平时说的算法的时间复杂度说的都是最差的时间复杂度。一般只考虑最差时间复杂度。

## 空间复杂度

> **空间复杂度（Space Complexity）**：在问题的输入规模为 N 的条件下，算法所占用的空间大小，可以记作为 S(N)。一般将 **算法的辅助空间** 作为衡量空间复杂度的标准。

相比于算法的时间复杂度计算来说，算法的空间复杂度更容易计算，主要包括「局部变量（算法范围内定义的变量）所占用的存储空间」和「系统为实现递归（如果算法是递归的话）所使用的堆栈空间」两个部分。

如何计算空间复杂度。

```python
#O(1)
#这段代码不会因为问题规模的扩大而内存增大。
def add(n):
    a=1
    b=2
    c=a+b+n
    return c
```

```python
#O(N)
def apd(n):
    lst=[]
    for i in range(n):
        lst.append(i)
    return lst
def algorithm(n):
    if n==0:
        return 1
    return n*algorithm(n-1)
```

